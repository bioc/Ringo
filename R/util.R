
splitAndSimplify <- function(toSplit, bySplit, collapse.by="/", nameSep="[[:space:]]", doUnique=FALSE, doCollapse=TRUE){
  # function to
  # a: do split and make sure that no object has a combined name
  # b: return vector instead of list
  splitted <- split(toSplit,bySplit)
  if (doUnique) #should 2 or more MRs of the same class be treated as only one?
    collapsefun <- function(x) paste(unique(x),collapse=collapse.by)
  else
    collapsefun <- function(x) paste(sort(x),collapse=collapse.by)
  if (!doCollapse) collapsefun <- function(x) sort(x)
  # 'sort' since order in DF does not seem to be genomic order:
  splitted <- unlist(lapply(splitted,collapsefun),use.names=TRUE)
  singleNames <- strsplit(names(splitted), nameSep)
  splitted <- rep(splitted,listLen(singleNames))
  names(splitted) <- unlist(singleNames, use.names=FALSE)
  return(splitted)
}# splitAndSimplify

## Auxiliary function to convert NimbleGen's feature report file into
### .xys file. Only use this function, if actual xys-file is not available
ftr2xys <- function(ftr.file, path=getwd()){  
  stopifnot(length(ftr.file)==1, is.character(ftr.file), grep(".ftr$",ftr.file)==1, file.exists(ftr.file))
  ftr.header <- scan(ftr.file,nlines=1,quiet=TRUE, what=character(0))
  xys.file <- gsub("ftr$","xys",ftr.file)
  ftr.data <- read.delim(ftr.file, as.is=TRUE, comment.char="#")
  xys.data <- ftr.data[,c("X","Y","SIGNAL_MEAN","FGD_PIX")]
  names(xys.data) <- c("X","Y","SIGNAL","COUNT")
  cat(ftr.header,"\n", sep=" ", file=file.path(path,xys.file))
  write.table(xys.data, file=file.path(path, xys.file), sep="\t", quote=FALSE, row.names=FALSE, col.names=TRUE, append=TRUE)
  invisible(NULL)
}#ftr2xys

## function to get runs of 1 in a binary vector, adopted from pairs project
clusters <- function(x, minLen=3, doSelect=FALSE) {
  x = c(0,x,0)
  diffx <- diff(x)
  start = which(diffx==1)
  end   = which(diffx==-1)
  len   = end-start
  if (doSelect) {
    sel   = len >= minLen
    start=start[sel]
    len=len[sel]
  } 
  cbind(start,len)
}#clusters

### function to take mean over sample groups in an ExpressionSet and
###  return an ExpressionSet holding those means
takeMeanOverGroups <- function(xSet, modColumn="Cy5")
{
  stopifnot(inherits(xSet,"ExpressionSet"), modColumn %in% names(pData(xSet)))

  grouping <- factor(pData(xSet)[[modColumn]])
  ngroups  <- nlevels(grouping)
  groupmat <- matrix(0, nrow=ncol(xSet), ncol=ngroups)
  for (i in 1:ngroups){
    thisLevel <- levels(grouping)[i]
    inGroup <- (grouping == thisLevel)
    nInGroup <- sum(inGroup, na.rm=TRUE)
    groupmat[inGroup,i] <- 1/nInGroup
  }
  # compute group-wise means for each probe
  datmat <- exprs(xSet)%*%groupmat
  colnames(datmat) <- as.character(levels(grouping))  
  ### TODO: combine pData as well meaningful
  new.df        <- data.frame(as.character(levels(grouping)))
  names(new.df) <- modColumn
  newPD <- new("AnnotatedDataFrame", data=new.df,
               varMetadata=data.frame("varLabel"=colnames(new.df),
                 row.names=colnames(new.df)))
  newEset <- new("ExpressionSet",  exprs=datmat, phenoData=newPD)
  featureNames(newEset) <- featureNames(xSet)
  return(newEset)
}#takeMeanOverGroups


compute.gc <- function(probe.sequences, digits=2){
  stopifnot(is.character(probe.sequences))
  splitted.seqs <- strsplit(toupper(probe.sequences),split="")
  round(sapply(splitted.seqs, function(x) length(grep("[GC]",x)))/
    listLen(splitted.seqs), digits=digits)
}#compute.gc


whichCsr <- function(X, arr.ind=TRUE){
  ## function to get a two-column matrix containing the indices of the
  ### non-zero elements in a "matrix.csr" class matrix
  stopifnot(inherits(X, "matrix.csr"))
  if (all(X@ra==0)) return(NULL)
  res <- cbind(rep(seq(dim(X)[1]),diff(X@ia)), # row indices
               X@ja )# column indices directly saved in matrix.csr format
  colnames(res) <- c("row","col")
  ## remove zero elements
  res <- res[X@ra != 0,,drop=FALSE]
  return(res)
}# whichCsr

getFeats <- function(cl){
  stopifnot(is.list(cl), inherits(cl[[1]],"cher"))
  return(unique(unlist(sapply(cl, function(cher) cher@extras[c("typeUpstream", "typeInside", "typeDownstream")]), use.names=FALSE)))
}# getFeats
